// Rotate for a square selection
// JUst in case the code breaks

void rotate_selection(Image *photo, int degrees) {
    int cols = photo->x2 - photo->x1; // Number of columns (x-axis range)
    int rows = photo->y2 - photo->y1; // Number of rows (y-axis range)

    // Normalize negative rotations
    if (degrees == -90) {
        degrees = 270;
    } else if (degrees == -270) {
        degrees = 90;
    } else if (degrees == -180) {
        degrees = 180;
    }

    // Temporary matrix for the rotated submatrix
    int **temp = (int **)malloc(cols * sizeof(int *));
    for (int i = 0; i < cols; i++) {
        temp[i] = (int *)malloc(rows * photo->pixel_depth * sizeof(int));
    }

    if (degrees == 90) {
        for (int i = 0; i < rows; i++) { // Rows
            for (int j = 0; j < cols; j++) { // Columns
                for (int k = 0; k < photo->pixel_depth; k++) {
                    temp[j][(rows - i - 1) * photo->pixel_depth + k] =
                        photo->pixels[photo->y1 + i][(photo->x1 + j) * photo->pixel_depth + k];
                }
            }
        }
    } else if (degrees == 180) {
        for (int i = 0; i < rows; i++) { // Rows
            for (int j = 0; j < cols; j++) { // Columns
                for (int k = 0; k < photo->pixel_depth; k++) {
                    temp[rows - i - 1][(cols - j - 1) * photo->pixel_depth + k] =
                        photo->pixels[photo->y1 + i][(photo->x1 + j) * photo->pixel_depth + k];
                }
            }
        }
    } else if (degrees == 270) {
        for (int i = 0; i < rows; i++) { // Rows
            for (int j = 0; j < cols; j++) { // Columns
                for (int k = 0; k < photo->pixel_depth; k++) {
                    temp[cols - j - 1][i * photo->pixel_depth + k] =
                        photo->pixels[photo->y1 + i][(photo->x1 + j) * photo->pixel_depth + k];
                }
            }
        }
    } else {
        printf("WRONG DEGREE\n");
    }

    // Copy rotated submatrix back to the original matrix
    for (int i = 0; i < rows; i++) { // Rows
        for (int j = 0; j < cols; j++) { // Columns
            for (int k = 0; k < photo->pixel_depth; k++) {
                photo->pixels[photo->y1 + i][(photo->x1 + j) * photo->pixel_depth + k] =
                    temp[i][j * photo->pixel_depth + k];
            }
        }
    }

    // Free the temporary matrix
    for (int i = 0; i < cols; i++) {
        free(temp[i]);
    }
    free(temp);
}
